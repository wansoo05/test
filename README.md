# Java의 자료형
1.  정수형

byte, short, int, long이 있으며, 주로 사용되는 것은 int와 long이다.

    byte(1 byte) < short(2 byte) < int(4 byte) < long(8 byte)

* byte랑 short를 사용하기 보다는 int를 사용하도록하자. byte와 short는 int보다 크기가 작아서 메모리를 좀 더 절약할 수는 있지만, 저장할 수 있는 값의 범위가 작은 편이라서 연산시에 범위를 넘어서 잘못된 결과를 얻기가 쉽다. 그리고 JVM의 피연산자 스택이 피연산자를 4 byte단위로 저장하기 때문에 크기가 4 byte보다 작은 자료형의 값을 계산할 때는 4 byte로 변환하여 연산이 수행된다. 그래서 오히려 int를 사용하는 것이 더 효율적이다.

10진수 외에도 16진수 또는 8진수로 표현된 정수를 변수에 저장할 수 있다. 16진수는 리터럴 앞에'0X'를, 8진수는 '0'을 붙인다.   

    int octNumber = 010;   //8진수 10, 10진수로는 8
    int hexNumber = 0x10;  //16진수 10, 10진수로는 16

* 정수형의 값의 범위는 **-2^(n-1) ~ 2^n-1**이다(n은 bit수). 왜냐 하면 정수형은 0과 1로 이루어진 2진수로 저장된다. 예를 들어 byte 형의 크기가 1byte이고 bit로는 8bit이므로 byte형은 8자리의 2진수로 표현할 수 있다. 정수형은 0을 포함한 양수와 음수를 저장 가능하기 때문에 8자리중 첫번째 자리는 부호자리로 사용된다. 그래서 실제로 값을 표현 할 수 있는 자리수는 모두 7개, 그래서 **-2^7 ~ 2^7-1**이 되는것이다.   

* long타입의 리터럴에는 접미사 'L' 또는 'l'을 반드시 붙여야 한다. 'l'은 숫자1과 혼동되므로 'L'을 사용하자.

* 정수형의 값의 범위가 초과가 되면, 에러가 발생하지는 않지만 최소값부터 다시 반복된다. 예를들어 byte의 경우 최대값이 127인데 128을 저장하려고 하면 -128로 저장된다. (단, 초기화에서는 값의 범위의 초과를 허용하지 않는다.)

2. 실수형

float, double이 있다. 실수는 부동소수점 방식으로 저장된다. 부동 소수점 방식은 실수를 +-a*10^n의 형태로 표현하는 것인데, a는 가수이고 n은 지수이다.(단, a는 0<=a<1인 실수) 예를들어 3.1415를 부동소수점 방식으로 표현하면 0.31415X10 이며 가수는 0.31415이고 지수는 1이다.

    float(4 byte) < double(8 byte)

* float보다 double이 약 두 배의 자리수가 배정되어 있기 때문에 float보다 double의 정밀도(소수점 이하의 자리수)가 더 높은 값을 표현할 수 있다는 것을 알 수 있다.

* float형 리터럴에는 접미사 f가 사용되고, double형 리터럴에는 d(실수의 기본 자료형이기 때문에 생략가능)가 사용된다.s